# Замыкание (closure) или фабричная функция это функция определяемая и возвращаемая другой функцией, при этом имеет доступ к значениям и объектам в области видимости "родительской" (или объемлющей) функции независимо откуда происходит вызов замыкания.
# Замыкания имеют доступ к самим объектам из области видимости родительской функции, а не к их копиям или состояниям существующим на момент определения замыкания
def outers(lst):
    def closure():
        return lst[0] * 2
    return closure
x = ['a']
closure_foo = outers(x)    # Вызываем внешнюю функцию, передав ей список в качестве аргумента
print(closure_foo())       # aa
x[0] = 'b'                 # меняем единственный элемент списка
print(closure_foo())       # bb
#
# Замыкание "запоминает" именно те объекты и значения, что были доступны родительской функции в момент его определения, что позволяет использовать сразу несколько экземпляров замыканий, отличных друг от друга. В качестве замыкания может быть лямбда
def multiplier(factor):
    return lambda x: factor * x
double = multiplier(2)
triple = multiplier(3)
print(double(5))  # 10 результат аналогичен вызову multiplier(2)(5)
print(triple(4))  # 12 результат аналогичен вызову multiplier(3)(4)
#
# Замыкания способны изменять значения и объекты из области видимости родительской функции, для этого используется оператор nonlocal
def count_calls():
    cntr = 0
    def closure(print_result=False):
        nonlocal cntr
        if not print_result:
            cntr += 1
        return cntr
    return closure
counter = count_calls()     # Вызвав функцию, получаем счетчик (замыкание)
for _ in range(5): counter()# Вызываем счетчик
print(counter(True))        # Проверяем результат подсчета: 5
for _ in range(2): counter()
print(counter(True))        # 7
